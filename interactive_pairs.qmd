---
title: "Interactive Pairs Trading Analysis"
format:
  html:
    theme: cosmo
    toc: true
    server: shiny
---

```{python}
#| echo: false
#| context: setup

import numpy as np
import pandas as pd
import datetime
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller, coint
import matplotlib.pyplot as plt
import shinybroker as sb
from shiny import ui, reactive, render
```

## Select Stock Pairs for Analysis

```{python}
#| echo: false
#| context: input

# Major stock symbols from different sectors for user selection
stocks_options = [
    "AAPL", "MSFT", "AMZN", "GOOGL", "FB", "TSLA", "NVDA", "JPM",
    "V", "JNJ", "WMT", "PG", "UNH", "HD", "BAC", "MA", "DIS", "ADBE",
    "CRM", "NFLX", "PYPL", "INTC", "VZ", "KO", "PEP", "CMCSA", "ABT",
    "T", "CSCO", "MRK", "PFE", "TMO", "ABBV", "ACN", "NKE", "XOM",
    "CVX", "LLY", "AVGO", "QCOM", "TXN", "MCD", "COST", "NEE", "MS",
    "BMY", "LIN", "SBUX", "AZO", "ORLY", "AMGN", "MDT", "HON", "IBM"
]

ui.card(
    ui.card_header("Select Stock Pairs"),
    ui.input_select("stock_a", "Stock A:", choices=stocks_options, selected="AZO"),
    ui.input_select("stock_b", "Stock B:", choices=stocks_options, selected="ORLY"),
    ui.input_numeric("initial_capital", "Initial Capital ($):", value=1000000, step=100000),
    ui.input_numeric("shares_per_trade", "Shares Per Trade:", value=100, step=10),
    ui.input_slider("stop_loss_pct", "Stop Loss Percentage:", min=1, max=10, value=5, step=1),
    ui.input_action_button("analyze", "Analyze Pair", class_="btn-primary")
)
```

```{python}
#| echo: false
#| context: server

# Initialize reactive values
rv = reactive.Value({
    'data': None,
    'blotter': None,
    'ledger': None,
    'has_data': False,
    'stock_a_symbol': None,
    'stock_b_symbol': None,
    'correlation': None,
    'pvalue': None,
    'adf_result': None,
    'half_life': None,
    'max_holding_time': None,
    'rho': None,
    'initial_cash': None,
    'final_value': None,
    'total_return': None,
    'annualized_return': None,
    'annualized_volatility': None,
    'sharpe_ratio': None,
    'max_drawdown': None
})

@reactive.Effect
@reactive.event(input.analyze)
def analyze_pair():
    # Get user inputs
    stock_a_symbol = input.stock_a()
    stock_b_symbol = input.stock_b()
    initial_cash = input.initial_capital()
    shares_per_trade = input.shares_per_trade()
    stop_loss_pct = input.stop_loss_pct() / 100  # Convert to decimal

    # Define contracts
    stock_a = sb.Contract({'symbol': stock_a_symbol, 'secType': "STK", 'exchange': "SMART", 'currency': "USD"})
    stock_b = sb.Contract({'symbol': stock_b_symbol, 'secType': "STK", 'exchange': "SMART", 'currency': "USD"})

    try:
        # Fetch data
        stock_a_data = sb.fetch_historical_data(contract=stock_a, barSizeSetting="1 day", durationStr="1 Y")['hst_dta']
        stock_b_data = sb.fetch_historical_data(contract=stock_b, barSizeSetting="1 day", durationStr="1 Y")['hst_dta']

        # Extract or fallback to generated dates
        try:
            date_column = next((col for col in ['date', 'time'] if col in stock_a_data.columns), None)
            if not date_column:
                date_column = [col for col in stock_a_data.columns if 'date' in col.lower() or 'time' in col.lower()][0]
            data = pd.DataFrame({
                'Date': pd.to_datetime(stock_a_data[date_column]),
                'Stock_A_Price': stock_a_data['close'],
                'Stock_B_Price': stock_b_data['close']
            })
        except:
            data = pd.DataFrame({
                'Stock_A_Price': stock_a_data['close'],
                'Stock_B_Price': stock_b_data['close']
            })
            end_date = datetime.datetime.now()
            start_date = end_date - datetime.timedelta(days=365)
            trading_days = pd.date_range(start=start_date, periods=len(data), freq='B')
            data['Date'] = trading_days

        # Ensure Date is datetime type
        data['Date'] = pd.to_datetime(data['Date'])

        # Calculate metrics
        data['Log_Spread'] = np.log(data['Stock_A_Price']) - np.log(data['Stock_B_Price'])
        data['roll_mean'] = data['Log_Spread'].rolling(window=20).mean()
        data['roll_std'] = data['Log_Spread'].rolling(window=20).std()
        data['Z_Score'] = (data['Log_Spread'] - data['roll_mean']) / data['roll_std']

        # Statistical Analysis
        correlation = data['Stock_A_Price'].corr(data['Stock_B_Price'])
        score, pvalue, _ = coint(data['Stock_A_Price'], data['Stock_B_Price'])
        adf_result = adfuller(data['Log_Spread'].dropna())

        # Half-life Calculation
        def calculate_half_life(spread):
            """Calculate half-life of the spread series"""
            spread_lag = spread.shift(1)
            spread_diff = spread - spread_lag

            # Remove missing values
            spread_lag = spread_lag.dropna()
            spread_diff = spread_diff.dropna()

            # Set up regression model: ΔSpread_t = α + ρ*Spread_{t-1} + ε_t
            spread_lag = sm.add_constant(spread_lag)

            # Run OLS regression
            model = sm.OLS(spread_diff.iloc[1:], spread_lag.iloc[1:])
            results = model.fit()

            # Get coefficient for Spread_{t-1} (ρ)
            rho = results.params.iloc[1]

            # Calculate half-life: t_{1/2} = -ln(2)/ln(1+ρ)
            if rho >= 0:  # No mean reversion
                half_life = np.inf
            else:
                half_life = -np.log(2) / rho

            return half_life, results, rho

        half_life, regression_results, rho = calculate_half_life(data['Log_Spread'])

        # Set maximum holding time
        max_holding_time = int(1.5 * half_life) if half_life < 100 else 20

        # Adjust thresholds based on price volatility
        data['price_vol'] = data['Stock_A_Price'].pct_change().rolling(20).std() * 100
        data['price_vol'].fillna(15, inplace=True)

        conditions = [
            (data['price_vol'] < 20),
            (data['price_vol'] >= 20) & (data['price_vol'] < 25),
            (data['price_vol'] >= 25) & (data['price_vol'] < 30),
            (data['price_vol'] >= 30)
        ]
        choices = [2.0, 2.25, 2.5, 3.0]
        data['threshold'] = np.select(conditions, choices, default=2.0)

        # Define trading periods
        def define_trading_periods(df, period_length_days=5):
            """Divide daily data into trading periods"""
            df = df.copy()
            df = df.sort_values('Date').reset_index(drop=True)
            first_date = df['Date'].iloc[0]
            # Calculate days difference manually
            days_diff = [(date - first_date).days for date in df['Date']]
            df['trading_period'] = [day_diff // period_length_days for day_diff in days_diff]
            return df

        # Set trading periods
        period_length_days = 5  # Each trading period is 5 days
        data = define_trading_periods(data, period_length_days)

        # Generate trading signals
        data['signal'] = 0
        data.loc[data['Z_Score'] > data['threshold'], 'signal'] = -1  # Short Stock A, Long Stock B
        data.loc[data['Z_Score'] < -data['threshold'], 'signal'] = 1  # Long Stock A, Short Stock B

        # Exit signal (Z-score reverts to ±0.5)
        data['exit_signal'] = 0
        data.loc[(data['Z_Score'] <= 0.5) & (data['Z_Score'] >= -0.5), 'exit_signal'] = 1

        # Initialize blotter and ledger
        trading_periods = data['trading_period'].unique()[1:]  # Start from the second trading period

        blotter = pd.DataFrame({
            'trading_period': trading_periods,
            'entry_timestamp': pd.NaT,
            'qty': 0,
            'exit_timestamp': pd.NaT,
            'entry_price_A': 0.0,
            'entry_price_B': 0.0,
            'exit_price_A': 0.0,
            'exit_price_B': 0.0,
            'success': None,
            'pnl_A': 0.0,
            'pnl_B': 0.0,
            'total_pnl': 0.0,
            'trade_type': None,
            'position_A': None,
            'position_B': None
        }).set_index('trading_period')

        # Initialize ledger
        first_period = data['trading_period'].iloc[0]
        dates_after_first_period = data[data['trading_period'] > first_period]['Date'].tolist()

        ledger = pd.DataFrame({
            'date': dates_after_first_period,
            'position': 0,
            'cash': 0.0,
            'mark_A': data[data['trading_period'] > first_period]['Stock_A_Price'].values,
            'mark_B': data[data['trading_period'] > first_period]['Stock_B_Price'].values,
            'mkt_value': 0.0
        })

        # Set initial cash
        ledger['cash'] = initial_cash

        # Track current position
        current_position = 0
        entry_price_A = 0
        entry_price_B = 0
        entry_date = None
        current_period = None

        # Trading execution loop
        filtered_data = data[data['trading_period'] > data['trading_period'].iloc[0]]

        for i, row in filtered_data.iterrows():
            current_date = row['Date']
            current_period = row['trading_period']

            # Find index for current date in ledger
            ledger_idx = ledger[ledger['date'] == current_date].index

            if len(ledger_idx) == 0:
                continue

            ledger_idx = ledger_idx[0]

            # Check if there's an entry signal and no current position
            if row['signal'] != 0 and current_position == 0:
                # Record entry information
                current_position = row['signal'] * shares_per_trade
                entry_price_A = row['Stock_A_Price']
                entry_price_B = row['Stock_B_Price']
                entry_date = current_date

                # Update blotter
                blotter.loc[current_period, 'entry_timestamp'] = current_date
                blotter.loc[current_period, 'qty'] = abs(current_position)
                blotter.loc[current_period, 'entry_price_A'] = entry_price_A
                blotter.loc[current_period, 'entry_price_B'] = entry_price_B

                if current_position > 0:
                    blotter.loc[current_period, 'trade_type'] = f'Long {stock_a_symbol}, Short {stock_b_symbol}'
                    blotter.loc[current_period, 'position_A'] = 'LONG'
                    blotter.loc[current_period, 'position_B'] = 'SHORT'
                else:
                    blotter.loc[current_period, 'trade_type'] = f'Short {stock_a_symbol}, Long {stock_b_symbol}'
                    blotter.loc[current_period, 'position_A'] = 'SHORT'
                    blotter.loc[current_period, 'position_B'] = 'LONG'

                # Update ledger
                ledger.loc[ledger_idx, 'position'] = current_position

            # Check if there's an exit signal and current position exists
            elif ((row['exit_signal'] == 1 or
                  (entry_date and (current_date - entry_date).days > max_holding_time) or
                  (entry_price_A and entry_price_B and
                   abs(((row['Stock_A_Price']/entry_price_A) - (row['Stock_B_Price']/entry_price_B))/2) > stop_loss_pct))
                  and current_position != 0):

                # Calculate pairs trading P&L
                exit_price_A = row['Stock_A_Price']
                exit_price_B = row['Stock_B_Price']

                # Calculate P&L for both directions
                if current_position > 0:  # Long Stock A, Short Stock B
                    pnl_A = current_position * (exit_price_A - entry_price_A)
                    pnl_B = current_position * (entry_price_B - exit_price_B)
                else:  # Short Stock A, Long Stock B
                    pnl_A = -current_position * (entry_price_A - exit_price_A)
                    pnl_B = -current_position * (exit_price_B - entry_price_B)

                total_pnl = pnl_A + pnl_B

                # Update blotter
                period_of_entry = blotter[blotter['entry_timestamp'] == entry_date].index
                if len(period_of_entry) > 0:
                    period_of_entry = period_of_entry[0]
                    blotter.loc[period_of_entry, 'exit_timestamp'] = current_date
                    blotter.loc[period_of_entry, 'exit_price_A'] = exit_price_A
                    blotter.loc[period_of_entry, 'exit_price_B'] = exit_price_B
                    blotter.loc[period_of_entry, 'success'] = total_pnl > 0
                    blotter.loc[period_of_entry, 'pnl_A'] = pnl_A
                    blotter.loc[period_of_entry, 'pnl_B'] = pnl_B
                    blotter.loc[period_of_entry, 'total_pnl'] = total_pnl

                # Update ledger cash
                if ledger_idx > 0:
                    ledger.loc[ledger_idx, 'cash'] = ledger.loc[ledger_idx-1, 'cash'] + total_pnl
                else:
                    ledger.loc[ledger_idx, 'cash'] = initial_cash + total_pnl

                # Reset position information
                current_position = 0
                entry_price_A = 0
                entry_price_B = 0
                entry_date = None

            else:
                # If no trade signal, copy cash from previous day
                if ledger_idx > 0:
                    ledger.loc[ledger_idx, 'cash'] = ledger.loc[ledger_idx-1, 'cash']
                else:
                    ledger.loc[ledger_idx, 'cash'] = initial_cash

            # Update position column in ledger
            ledger.loc[ledger_idx, 'position'] = current_position

            # Calculate market value (considering both positions)
            if current_position > 0:  # Long Stock A, Short Stock B
                value_A = current_position * row['Stock_A_Price']
                value_B = -current_position * row['Stock_B_Price']
            elif current_position < 0:  # Short Stock A, Long Stock B
                value_A = current_position * row['Stock_A_Price']
                value_B = -current_position * row['Stock_B_Price']
            else:
                value_A = 0
                value_B = 0

            # Total market value = Cash + Stock A position value + Stock B position value
            ledger.loc[ledger_idx, 'mkt_value'] = ledger.loc[ledger_idx, 'cash'] + value_A + value_B

        # Clean blotter, keep only rows with trades
        blotter = blotter[blotter['entry_timestamp'].notna()]

        # Performance metrics
        initial_value = ledger['mkt_value'].iloc[0] if not ledger.empty else initial_cash
        final_value = ledger['mkt_value'].iloc[-1] if not ledger.empty else initial_cash
        total_return = (final_value - initial_value) / initial_value * 100

        # Calculate additional performance metrics
        annualized_return = None
        annualized_volatility = None
        sharpe_ratio = None
        max_drawdown = None

        if not ledger.empty:
            ledger['daily_return'] = ledger['mkt_value'].pct_change()
            annualized_return = ledger['daily_return'].mean() * 252 * 100
            annualized_volatility = ledger['daily_return'].std() * np.sqrt(252) * 100
            sharpe_ratio = annualized_return / annualized_volatility if annualized_volatility != 0 else 0
            max_drawdown = (ledger['mkt_value'] / ledger['mkt_value'].cummax() - 1).min() * 100

        # Update reactive values
        rv.set({
            'data': data,
            'blotter': blotter,
            'ledger': ledger,
            'has_data': True,
            'stock_a_symbol': stock_a_symbol,
            'stock_b_symbol': stock_b_symbol,
            'correlation': correlation,
            'pvalue': pvalue,
            'adf_result': adf_result,
            'half_life': half_life,
            'max_holding_time': max_holding_time,
            'rho': rho,
            'initial_cash': initial_cash,
            'final_value': final_value,
            'total_return': total_return,
            'annualized_return': annualized_return,
            'annualized_volatility': annualized_volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown
        })

    except Exception as e:
        print(f"Error: {e}")
        return
```

## Pair Information

```{python}
#| echo: false
#| context: output
#| height: 300

@render.ui
def pair_info():
    if not rv()['has_data']:
        return ui.p("Please select stock pairs and click 'Analyze Pair' to begin the analysis.")

    stock_a_symbol = rv()['stock_a_symbol']
    stock_b_symbol = rv()['stock_b_symbol']

    return ui.div(
        ui.h3(f"Stock Pair: {stock_a_symbol} vs {stock_b_symbol}"),
        ui.p(
            ui.strong(f"{stock_a_symbol}:"),
            " Stock A in the pair analysis"
        ),
        ui.p(
            ui.strong(f"{stock_b_symbol}:"),
            " Stock B in the pair analysis"
        )
    )
```

## Statistical Analysis

```{python}
#| echo: false
#| context: output

@render.ui
def statistical_analysis():
    if not rv()['has_data']:
        return ui.p("")

    correlation = rv()['correlation']
    pvalue = rv()['pvalue']
    adf_result = rv()['adf_result']
    half_life = rv()['half_life']
    rho = rv()['rho']
    max_holding_time = rv()['max_holding_time']

    # Define correlation strength
    if correlation >= 0.7:
        correlation_conclusion = "Strong correlation (≥0.7), suitable for pairs trading"
    elif correlation >= 0.5:
        correlation_conclusion = "Moderate correlation (0.5-0.7), potentially suitable for pairs trading"
    else:
        correlation_conclusion = "Weak correlation (<0.5), not very suitable for pairs trading"

    # Determine suitability count
    suitable_count = 0
    if correlation >= 0.7:
        suitable_count += 1
    if pvalue < 0.05 or adf_result[1] < 0.05:
        suitable_count += 1
    if 5 <= half_life <= 60:
        suitable_count += 1

    # Overall suitability conclusion
    stock_a_symbol = rv()['stock_a_symbol']
    stock_b_symbol = rv()['stock_b_symbol']

    if suitable_count == 3:
        suitability = f"{stock_a_symbol} and {stock_b_symbol} are very suitable for pairs trading, meeting all test conditions"
    elif suitable_count == 2:
        suitability = f"{stock_a_symbol} and {stock_b_symbol} are somewhat suitable for pairs trading, meeting most test conditions"
    else:
        suitability = f"{stock_a_symbol} and {stock_b_symbol} may not be suitable for pairs trading, failing to meet most test conditions"

    return ui.div(
        ui.h3("Statistical Analysis"),
        ui.h4("Correlation Analysis:"),
        ui.p(f"Pearson correlation coefficient: {correlation:.4f}"),
        ui.p(f"Conclusion: {correlation_conclusion}"),

        ui.h4("Cointegration Test:"),
        ui.p(f"p-value: {pvalue:.4f}"),
        ui.p(f"Conclusion: Pair is{' ' if pvalue < 0.05 else ' not '} cointegrated (p-value {'<' if pvalue < 0.05 else '≥'} 0.05)"),

        ui.h4("Augmented Dickey-Fuller Test:"),
        ui.p(f"ADF Statistic: {adf_result[0]:.4f}"),
        ui.p(f"p-value: {adf_result[1]:.4f}"),
        ui.p(f"Conclusion: Spread is{' ' if adf_result[1] < 0.05 else ' not '} stationary (p-value {'<' if adf_result[1] < 0.05 else '≥'} 0.05)"),

        ui.h4("Mean Reversion Analysis:"),
        ui.p(f"Regression coefficient (ρ): {rho:.4f}"),
        ui.p(f"Half-life: {half_life:.2f} days"),
        ui.p(f"Recommended maximum holding time: {max_holding_time} days"),

        ui.h4("Overall Suitability:"),
        ui.p(suitability, class_="lead")
    )
```

## Trading Blotter

```{python}
#| echo: false
#| context: output

@render.table
def render_blotter():
    if not rv()['has_data'] or rv()['blotter'] is None or rv()['blotter'].empty:
        return pd.DataFrame({"Message": ["No trades executed in the backtest period."]})

    stock_a_symbol = rv()['stock_a_symbol']
    stock_b_symbol = rv()['stock_b_symbol']

    # Format the blotter for display
    display_blotter = rv()['blotter'].copy()
    display_blotter = display_blotter.reset_index()

    # Create a more organized display
    display_blotter = display_blotter[['entry_timestamp', 'exit_timestamp',
                                      'position_A', 'position_B', 'qty',
                                      'entry_price_A', 'exit_price_A', 'pnl_A',
                                      'entry_price_B', 'exit_price_B', 'pnl_B',
                                      'total_pnl', 'success']]

    # Rename columns for clarity
    display_blotter = display_blotter.rename(columns={
        'position_A': f'{stock_a_symbol} Position',
        'position_B': f'{stock_b_symbol} Position',
        'qty': 'Quantity',
        'entry_price_A': f'{stock_a_symbol} Entry',
        'exit_price_A': f'{stock_a_symbol} Exit',
        'pnl_A': f'{stock_a_symbol} P&L',
        'entry_price_B': f'{stock_b_symbol} Entry',
        'exit_price_B': f'{stock_b_symbol} Exit',
        'pnl_B': f'{stock_b_symbol} P&L',
        'total_pnl': 'Total P&L'
    })

    return display_blotter
```

## Ledger (Positions)

```{python}
#| echo: false
#| context: output

@render.table
def render_ledger():
    if not rv()['has_data'] or rv()['ledger'] is None or rv()['ledger'].empty:
        return pd.DataFrame({"Message": ["No positions in the ledger."]})

    stock_a_symbol = rv()['stock_a_symbol']
    stock_b_symbol = rv()['stock_b_symbol']

    # Format the ledger for display
    display_ledger = rv()['ledger'].copy()

    # Rename columns for clarity
    display_ledger = display_ledger.rename(columns={
        'mark_A': f'{stock_a_symbol} Price',
        'mark_B': f'{stock_b_symbol} Price',
        'mkt_value': 'Portfolio Value'
    })

    display_ledger = display_ledger[['date', 'position', 'cash',
                                    f'{stock_a_symbol} Price',
                                    f'{stock_b_symbol} Price',
                                    'Portfolio Value']]

    # Filter to only show rows with active positions
    display_ledger = display_ledger[display_ledger['position'] != 0]

    if display_ledger.empty:
        return pd.DataFrame({"Message": ["No active positions in the ledger."]})

    return display_ledger
```

## Performance Metrics

```{python}
#| echo: false
#| context: output

@render.ui
def performance_metrics():
    if not rv()['has_data']:
        return ui.p("")

    initial_cash = rv()['initial_cash']
    final_value = rv()['final_value']
    total_return = rv()['total_return']
    annualized_return = rv()['annualized_return']
    annualized_volatility = rv()['annualized_volatility']
    sharpe_ratio = rv()['sharpe_ratio']
    max_drawdown = rv()['max_drawdown']

    return ui.div(
        ui.h3("Performance Metrics"),
        ui.div(
            ui.div(
                ui.metric_value(f"${initial_cash:,.2f}"),
                ui.metric_label("Initial Capital"),
                class_="col-md-3"
            ),
            ui.div(
                ui.metric_value(f"${final_value:,.2f}"),
                ui.metric_label("Final Assets"),
                class_="col-md-3"
            ),
            ui.div(
                ui.metric_value(f"{total_return:.2f}%"),
                ui.metric_label("Total Return"),
                class_="col-md-3"
            ),
            class_="row"
        ),
        ui.br(),
        ui.div(
            ui.div(
                ui.metric_value(f"{annualized_return:.2f}%" if annualized_return is not None else "N/A"),
                ui.metric_label("Annualized Return"),
                class_="col-md-3"
            ),
            ui.div(
                ui.metric_value(f"{annualized_volatility:.2f}%" if annualized_volatility is not None else "N/A"),
                ui.metric_label("Annualized Volatility"),
                class_="col-md-3"
            ),
            ui.div(
                ui.metric_value(f"{sharpe_ratio:.4f}" if sharpe_ratio is not None else "N/A"),
                ui.metric_label("Sharpe Ratio"),
                class_="col-md-3"
            ),
            ui.div(
                ui.metric_value(f"{max_drawdown:.2f}%" if max_drawdown is not None else "N/A"),
                ui.metric_label("Maximum Drawdown"),
                class_="col-md-3"
            ),
            class_="row"
        )
    )
```

## Price and Z-Score Charts

```{python}
#| echo: false
#| context: output
#| fig-width: 12
#| fig-height: 10

@render.plot
def price_charts():
    if not rv()['has_data']:
        return plt.figure()

    data = rv()['data']
    stock_a_symbol = rv()['stock_a_symbol']
    stock_b_symbol = rv()['stock_b_symbol']

    fig = plt.figure(figsize=(12, 10))

    # Price trend subplot
    plt.subplot(3, 1, 1)
    plt.plot(data['Date'], data['Stock_A_Price'], label=stock_a_symbol)
    plt.plot(data['Date'], data['Stock_B_Price'], label=stock_b_symbol)
    plt.title(f'{stock_a_symbol} vs {stock_b_symbol} Price Trend')
    plt.xlabel('Date')
    plt.ylabel('Price ($)')
    plt.legend()
    plt.grid(True)

    # Price ratio subplot
    plt.subplot(3, 1, 2)
    plt.plot(data['Date'], data['Log_Spread'])
    plt.title(f'Log Spread (log({stock_a_symbol}) - log({stock_b_symbol}))')
    plt.xlabel('Date')
    plt.ylabel('Log Spread')
    plt.grid(True)

    # Z-score subplot
    plt.subplot(3, 1, 3)
    plt.plot(data['Date'], data['Z_Score'])
    plt.axhline(y=2.0, color='r', linestyle='--', label='Entry Threshold (+2.0)')
    plt.axhline(y=-2.0, color='r', linestyle='--', label='Entry Threshold (-2.0)')
    plt.axhline(y=0.5, color='g', linestyle='--', label='Exit Threshold (+0.5)')
    plt.axhline(y=-0.5, color='g', linestyle='--', label='Exit Threshold (-0.5)')
    plt.title('Z-Score')
    plt.xlabel('Date')
    plt.ylabel('Z-Score')
    plt.legend()
    plt.grid(True)

    plt.tight_layout()
    return fig
```

```{python}
#| echo: false
#| context: output

@render.ui
def final_analysis():
    if not rv()['has_data']:
        return ui.p("")

    stock_a_symbol = rv()['stock_a_symbol']
    stock_b_symbol = rv()['stock_b_symbol']
    correlation = rv()['correlation']
    half_life = rv()['half_life']
    total_return = rv()['total_return']
    sharpe_ratio = rv()['sharpe_ratio']

    if correlation >= 0.7 and half_life < 100 and half_life > 0 and total_return > 0:
        conclusion = f"The pair {stock_a_symbol}/{stock_b_symbol} shows strong potential for pairs trading."
        details = "The stocks are highly correlated, show mean reversion properties, and generated positive returns in backtesting."
    elif correlation >= 0.5 and total_return > 0:
        conclusion = f"The pair {stock_a_symbol}/{stock_b_symbol} shows moderate potential for pairs trading."
        details = "The stocks show acceptable correlation and generated positive returns, but may need additional risk management."
    else:
        conclusion = f"The pair {stock_a_symbol}/{stock_b_symbol} may not be ideal for pairs trading."
        details = "Consider selecting stocks with higher correlation and better mean reversion properties."

    return ui.card(
        ui.card_header("Trading Conclusion"),
        ui.markdown(f"""
        ### {conclusion}

        {details}

        **Key metrics summary:**
        - Correlation: {correlation:.4f}
        - Half-life: {half_life:.2f} days
        - Total Return: {total_return:.2f}%
        - Sharpe Ratio: {sharpe_ratio:.4f if sharpe_ratio is not None else 'N/A'}

        > Note: This analysis is based on historical data and does not guarantee future performance. Always conduct your own due diligence before trading.
        """)
    )
```