---
title: "Pairs Trading Analysis: AZO vs ORLY"
format:
  html:
    theme: cosmo
    toc: true
jupyter: python3
---

## Pair Trading Signals – AZO vs ORLY

```{python}
#| echo: false
import numpy as np
import pandas as pd
import shinybroker as sb
import datetime
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller, coint
import matplotlib.pyplot as plt

STOCK1_SYMBOL = "AZO"
STOCK2_SYMBOL = "ORLY"

# Define contracts
stock1 = sb.Contract({'symbol': STOCK1_SYMBOL, 'secType': "STK", 'exchange': "SMART", 'currency': "USD"})
stock2 = sb.Contract({'symbol': STOCK2_SYMBOL, 'secType': "STK", 'exchange': "SMART", 'currency': "USD"})

# Fetch data
stock1_data = sb.fetch_historical_data(contract=stock1, barSizeSetting="1 day", durationStr="1 Y")['hst_dta']
stock2_data = sb.fetch_historical_data(contract=stock2, barSizeSetting="1 day", durationStr="1 Y")['hst_dta']

# Extract or fallback to generated dates
try:
    date_column = next((col for col in ['date', 'time'] if col in stock1_data.columns), None)
    if not date_column:
        date_column = [col for col in stock1_data.columns if 'date' in col.lower() or 'time' in col.lower()][0]
    data = pd.DataFrame({
        'Date': pd.to_datetime(stock1_data[date_column]),
        'Stock1_Price': stock1_data['close'],
        'Stock2_Price': stock2_data['close']
    })
except:
    data = pd.DataFrame({
        'Stock1_Price': stock1_data['close'],
        'Stock2_Price': stock2_data['close']
    })
    end_date = datetime.datetime.now()
    start_date = end_date - datetime.timedelta(days=365)
    trading_days = pd.date_range(start=start_date, periods=len(data), freq='B')
    data['Date'] = trading_days

# Ensure Date is datetime type
data['Date'] = pd.to_datetime(data['Date'])

# Calculate metrics
data['Log_Spread'] = np.log(data['Stock1_Price']) - np.log(data['Stock2_Price'])
data['roll_mean'] = data['Log_Spread'].rolling(window=20).mean()
data['roll_std'] = data['Log_Spread'].rolling(window=20).std()
data['Z_Score'] = (data['Log_Spread'] - data['roll_mean']) / data['roll_std']

# Prepare for output
results_df = data[['Date', 'Stock1_Price', 'Stock2_Price', 'Log_Spread', 'Z_Score']].tail(20)
results_df['Date'] = pd.to_datetime(results_df['Date'])
results_df = results_df.round({'Stock1_Price': 2, 'Stock2_Price': 2, 'Log_Spread': 6, 'Z_Score': 6})
results_df = results_df.sort_values(by="Date").reset_index(drop=True)
results_df
```

## Statistical Analysis

```{python}
#| echo: false
# Ensure data is sorted by date
data = data.sort_values('Date').reset_index(drop=True)

# Calculate correlation
correlation = data['Stock1_Price'].corr(data['Stock2_Price'])
print(f"Correlation Analysis:")
print(f"Pearson correlation coefficient: {correlation:.4f}")
if correlation >= 0.7:
    print("Conclusion: Strong correlation (≥0.7), suitable for pairs trading\n")
elif correlation >= 0.5:
    print("Conclusion: Moderate correlation (0.5-0.7), potentially suitable for pairs trading\n")
else:
    print("Conclusion: Weak correlation (<0.5), not very suitable for pairs trading\n")

# Cointegration Test
score, pvalue, _ = coint(data['Stock1_Price'], data['Stock2_Price'])

# ADF test
adf_result = adfuller(data['Log_Spread'].dropna())


# Half-life Calculation
def calculate_half_life(spread):
    """Calculate half-life of the spread series"""
    spread_lag = spread.shift(1)
    spread_diff = spread - spread_lag

    # Remove missing values
    spread_lag = spread_lag.dropna()
    spread_diff = spread_diff.dropna()

    # Set up regression model: ΔSpread_t = α + ρ*Spread_{t-1} + ε_t
    spread_lag = sm.add_constant(spread_lag)

    # Run OLS regression
    model = sm.OLS(spread_diff[1:], spread_lag[1:])
    results = model.fit()

    # Get coefficient for Spread_{t-1} (ρ)
    rho = results.params[1]

    # Calculate half-life: t_{1/2} = -ln(2)/ln(1+ρ)
    if rho >= 0:  # No mean reversion
        half_life = np.inf
    else:
        half_life = -np.log(2) / rho

    return half_life, results

half_life, regression_results = calculate_half_life(data['Log_Spread'])

# Set maximum holding time
max_holding_time = int(1.5 * half_life) if half_life < 100 else 20
```

## Trading Strategy Implementation

```{python}
#| echo: false
#| warning: false

# Try to get VIX index data
try:
    vix = sb.Contract({
        'symbol': "VIX",
        'secType': "IND",
        'exchange': "CBOE",
        'currency': "USD"
    })
    vix_data = sb.fetch_historical_data(
        contract=vix,
        barSizeSetting="1 day",
        durationStr="1 Y"
    )['hst_dta']
    has_vix = True
except:
    has_vix = False
    print("Unable to get VIX data, using default volatility thresholds")

if has_vix:
    data['VIX'] = vix_data['close']
else:
    # If no VIX data, use a simple estimate of price volatility
    data['VIX'] = data['Stock1_Price'].pct_change().rolling(20).std() * 100
    data['VIX'].fillna(15, inplace=True)  # Use 15 as default value

# Adjust thresholds based on VIX
conditions = [
    (data['VIX'] < 20),
    (data['VIX'] >= 20) & (data['VIX'] < 25),
    (data['VIX'] >= 25) & (data['VIX'] < 30),
    (data['VIX'] >= 30)
]
choices = [2.0, 2.25, 2.5, 3.0]
data['threshold'] = np.select(conditions, choices, default=2.0)

# Define trading periods - FIXED VERSION
def define_trading_periods(df, period_length_days=5):
    """Divide daily data into trading periods"""
    df = df.copy()
    df = df.sort_values('Date').reset_index(drop=True)
    first_date = df['Date'].iloc[0]
    # Calculate days difference manually instead of using dt accessor
    days_diff = [(date - first_date).days for date in df['Date']]
    df['trading_period'] = [day_diff // period_length_days for day_diff in days_diff]
    return df

# Set trading periods
period_length_days = 5  # Each trading period is 5 days
data = define_trading_periods(data, period_length_days)

# Generate trading signals
data['signal'] = 0
data.loc[data['Z_Score'] > data['threshold'], 'signal'] = -1  # Short Stock1, Long Stock2
data.loc[data['Z_Score'] < -data['threshold'], 'signal'] = 1  # Long Stock1, Short Stock2

# Exit signal (Z-score reverts to ±0.5)
data['exit_signal'] = 0
data.loc[(data['Z_Score'] <= 0.5) & (data['Z_Score'] >= -0.5), 'exit_signal'] = 1

# Initialize blotter and ledger
print(f"Trading period length: {period_length_days} days")

# Initialize blotter (each row represents a trading period)
trading_periods = data['trading_period'].unique()[1:]  # Start from the second trading period
print(f"Number of trading periods: {len(trading_periods)}")

blotter = pd.DataFrame({
    'trading_period': trading_periods,
    'entry_timestamp': pd.NaT,
    'qty': 0,
    'exit_timestamp': pd.NaT,
    'entry_price_A': 0.0,
    'entry_price_B': 0.0,
    'exit_price_A': 0.0,
    'exit_price_B': 0.0,
    'success': None,
    'pnl_A': 0.0,
    'pnl_B': 0.0,
    'total_pnl': 0.0,
    'trade_type': None
}).set_index('trading_period')

# Initialize ledger (each row represents a trading day)
first_period = data['trading_period'].iloc[0]
dates_after_first_period = data[data['trading_period'] > first_period]['Date'].tolist()

ledger = pd.DataFrame({
    'date': dates_after_first_period,
    'position': 0,
    'cash': 0.0,
    'mark_A': data[data['trading_period'] > first_period]['Stock1_Price'].values,
    'mark_B': data[data['trading_period'] > first_period]['Stock2_Price'].values,
    'mkt_value': 0.0
})

print(f"Number of ledger rows: {len(ledger)}")

# Set initial parameters
initial_cash = 1000000  # Initial capital $1M
shares_per_trade = 100  # Trade 100 shares each time
stop_loss_pct = 0.05   # 5% stop loss

print(f"Initial capital: ${initial_cash:,.2f}")
print(f"Shares per trade: {shares_per_trade}")
print(f"Stop-loss percentage: {stop_loss_pct*100}%")
print(f"Maximum holding time: {max_holding_time} days")

# Set initial cash
ledger['cash'] = initial_cash

# Track current position
current_position = 0
entry_price_A = 0
entry_price_B = 0
entry_date = None
current_period = None

# Trading execution loop
filtered_data = data[data['trading_period'] > data['trading_period'].iloc[0]]

for i, row in filtered_data.iterrows():
    current_date = row['Date']
    current_period = row['trading_period']

    # Find index for current date in ledger
    ledger_idx = ledger[ledger['date'] == current_date].index

    if len(ledger_idx) == 0:
        continue

    ledger_idx = ledger_idx[0]

    # Check if there's an entry signal and no current position
    if row['signal'] != 0 and current_position == 0:
        # Record entry information
        current_position = row['signal'] * shares_per_trade  # Positive means long Stock1/short Stock2, negative means short Stock1/long Stock2
        entry_price_A = row['Stock1_Price']
        entry_price_B = row['Stock2_Price']
        entry_date = current_date

        # Update blotter
        blotter.loc[current_period, 'entry_timestamp'] = current_date
        blotter.loc[current_period, 'qty'] = current_position
        blotter.loc[current_period, 'entry_price_A'] = entry_price_A
        blotter.loc[current_period, 'entry_price_B'] = entry_price_B

        if current_position > 0:
            blotter.loc[current_period, 'trade_type'] = f'Long {STOCK1_SYMBOL}, Short {STOCK2_SYMBOL}'
        else:
            blotter.loc[current_period, 'trade_type'] = f'Short {STOCK1_SYMBOL}, Long {STOCK2_SYMBOL}'

        # Update ledger
        ledger.loc[ledger_idx, 'position'] = current_position

    # Check if there's an exit signal and current position exists
    elif ((row['exit_signal'] == 1 or
          (entry_date and (current_date - entry_date).days > max_holding_time) or
          (entry_price_A and entry_price_B and
           abs(((row['Stock1_Price']/entry_price_A) - (row['Stock2_Price']/entry_price_B))/2) > stop_loss_pct))
          and current_position != 0):

        # Calculate pairs trading P&L
        exit_price_A = row['Stock1_Price']
        exit_price_B = row['Stock2_Price']

        # Calculate P&L for both directions
        if current_position > 0:  # Long Stock1, Short Stock2
            pnl_A = current_position * (exit_price_A - entry_price_A)  # Stock1 long P&L
            pnl_B = current_position * (entry_price_B - exit_price_B)  # Stock2 short P&L
        else:  # Short Stock1, Long Stock2
            pnl_A = -current_position * (entry_price_A - exit_price_A)  # Stock1 short P&L
            pnl_B = -current_position * (exit_price_B - entry_price_B)  # Stock2 long P&L

        total_pnl = pnl_A + pnl_B

        # Update blotter
        period_of_entry = blotter[blotter['entry_timestamp'] == entry_date].index
        if len(period_of_entry) == 0:
            pass
        else:
            period_of_entry = period_of_entry[0]
            blotter.loc[period_of_entry, 'exit_timestamp'] = current_date
            blotter.loc[period_of_entry, 'exit_price_A'] = exit_price_A
            blotter.loc[period_of_entry, 'exit_price_B'] = exit_price_B
            blotter.loc[period_of_entry, 'success'] = total_pnl > 0
            blotter.loc[period_of_entry, 'pnl_A'] = pnl_A
            blotter.loc[period_of_entry, 'pnl_B'] = pnl_B
            blotter.loc[period_of_entry, 'total_pnl'] = total_pnl

        # Update ledger cash
        if ledger_idx > 0:
            ledger.loc[ledger_idx, 'cash'] = ledger.loc[ledger_idx-1, 'cash'] + total_pnl
        else:
            ledger.loc[ledger_idx, 'cash'] = initial_cash + total_pnl

        # Reset position information
        current_position = 0
        entry_price_A = 0
        entry_price_B = 0
        entry_date = None

    else:
        # If no trade signal, copy cash from previous day
        if ledger_idx > 0:
            ledger.loc[ledger_idx, 'cash'] = ledger.loc[ledger_idx-1, 'cash']
        else:
            ledger.loc[ledger_idx, 'cash'] = initial_cash

    # Update position column in ledger
    ledger.loc[ledger_idx, 'position'] = current_position

    # Calculate market value (considering both positions)
    if current_position > 0:  # Long Stock1, Short Stock2
        value_A = current_position * row['Stock1_Price']  # Stock1 long value
        value_B = -current_position * row['Stock2_Price']  # Stock2 short value
    elif current_position < 0:  # Short Stock1, Long Stock2
        value_A = current_position * row['Stock1_Price']  # Stock1 short value
        value_B = -current_position * row['Stock2_Price']  # Stock2 long value
    else:
        value_A = 0
        value_B = 0

    # Total market value = Cash + Stock1 position value + Stock2 position value
    ledger.loc[ledger_idx, 'mkt_value'] = ledger.loc[ledger_idx, 'cash'] + value_A + value_B

# Clean blotter, keep only rows with trades
blotter = blotter[blotter['entry_timestamp'].notna()]
```

## Trading Results

### Blotter (Trade Records)

```{python}
#| echo: false
if blotter.empty:
    print("No trading records found in the backtest period.")
else:
    # Format the blotter for display
    display_blotter = blotter.copy()
    display_blotter = display_blotter.reset_index()
    display_blotter = display_blotter[['trading_period', 'entry_timestamp', 'exit_timestamp',
                                      'trade_type', 'qty', 'entry_price_A', 'exit_price_A',
                                      'entry_price_B', 'exit_price_B', 'pnl_A', 'pnl_B',
                                      'total_pnl', 'success']]
    # Format currency columns
    for col in ['pnl_A', 'pnl_B', 'total_pnl']:
        display_blotter[col] = display_blotter[col].map('${:,.2f}'.format)

    display(display_blotter)
```

### Ledger (Account Daily Status)

```{python}
#| echo: false
display_ledger = ledger.copy()
display_ledger = display_ledger[['date', 'position', 'cash', 'mark_A', 'mark_B', 'mkt_value']]


for col in ['cash', 'mark_A', 'mark_B', 'mkt_value']:
    display_ledger[col] = display_ledger[col].map('${:,.2f}'.format)

print("Ledger (first 10 rows):")
display(display_ledger.head(10))
```

### Performance Metrics

```{python}
#| echo: false
print("Strategy Performance Metrics:")
initial_value = ledger['mkt_value'].iloc[0] if not ledger.empty else initial_cash
final_value = ledger['mkt_value'].iloc[-1] if not ledger.empty else initial_cash
total_return = (final_value - initial_value) / initial_value * 100

print(f"Initial Capital: ${initial_cash:,.2f}")
print(f"Final Assets: ${final_value:,.2f}")
print(f"Total Return: {total_return:.2f}%")

# Calculate additional performance metrics
if not ledger.empty:
    ledger['daily_return'] = ledger['mkt_value'].pct_change()
    annualized_return = ledger['daily_return'].mean() * 252 * 100
    annualized_volatility = ledger['daily_return'].std() * np.sqrt(252) * 100
    sharpe_ratio = annualized_return / annualized_volatility if annualized_volatility != 0 else 0
    max_drawdown = (ledger['mkt_value'] / ledger['mkt_value'].cummax() - 1).min() * 100

    print(f"Annualized Return: {annualized_return:.2f}%")
    print(f"Annualized Volatility: {annualized_volatility:.2f}%")
    print(f"Sharpe Ratio: {sharpe_ratio:.4f}")
    print(f"Maximum Drawdown: {max_drawdown:.2f}%")
```

## Price and Z-Score Charts

```{python}
#| echo: false
#| fig-width: 12
#| fig-height: 10

plt.figure(figsize=(12, 10))

# Price trend subplot
plt.subplot(3, 1, 1)
plt.plot(data['Date'], data['Stock1_Price'], label=STOCK1_SYMBOL)
plt.plot(data['Date'], data['Stock2_Price'], label=STOCK2_SYMBOL)
plt.title(f'{STOCK1_SYMBOL} vs {STOCK2_SYMBOL} Price Trend')
plt.xlabel('Date')
plt.ylabel('Price ($)')
plt.legend()
plt.grid(True)

# Price ratio subplot
plt.subplot(3, 1, 2)
plt.plot(data['Date'], data['Log_Spread'])
plt.title(f'Log Spread (log({STOCK1_SYMBOL}) - log({STOCK2_SYMBOL}))')
plt.xlabel('Date')
plt.ylabel('Log Spread')
plt.grid(True)

# Z-score subplot
plt.subplot(3, 1, 3)
plt.plot(data['Date'], data['Z_Score'])
plt.axhline(y=2.0, color='r', linestyle='--', label='Entry Threshold (+2.0)')
plt.axhline(y=-2.0, color='r', linestyle='--', label='Entry Threshold (-2.0)')
plt.axhline(y=0.5, color='g', linestyle='--', label='Exit Threshold (+0.5)')
plt.axhline(y=-0.5, color='g', linestyle='--', label='Exit Threshold (-0.5)')
plt.title('Z-Score')
plt.xlabel('Date')
plt.ylabel('Z-Score')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()
```